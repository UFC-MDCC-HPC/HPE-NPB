# Introduction #

The code of the COPP (component-oriented parallel programming) versions of SP, BT, LU and FT have been obtained by a thorough refactoring process from their C#/MPI.NET monolithic versions.

For understanding the code in In http://npb-for-hpe.googlecode.com/svn/branches/hpe_version/, you must read the following itens:

  1. There is a folder for each component;
  1. The name of a folder concatenates a package name and a component name.
    * For instance, `bt.solve.UnpackSolveInfo` contains the code of the component `UnpackSolveInfo` of package `bt.solve`.
  1. _Concrete components_ always start with `impl` in their package names.
    * For instance, `impl.bt.solve.XUnpackSolveInfo` contains the concrete component `XUnpackSolveInfo`, which implements the component `UnpackSolveInfo` for the _x_ axis;
    * Thus, all folder whose name do not begin with `impl` contain _abstract components_, such as `bt.solve.UnpackSolveInfo`.
  1. In the folder of a component (concrete or abstract) named `xxx.yyy.zzz.AAA` (name `AAA` and package `xxx.yyy.zzz`), you have the following itens:
    * **`AAA.hpe` file**: the configuration of the component, in a xml format that the visual interface of the Front-End of HPE may interpret, describing the inner components (dependencies/uses ports) of the component and how they are combined to form its units;
    * **`src/<version>` folder**: the source code of the units, in C#. If the component is abstract, it contains an interface declaration. If the component is concrete, it contains a class declaration. The type parameters of the interface/class corresponds to the context parameters of the component. The source code of each unit may be automatically generated by the Front-End, comprising two files: a _base file_ and a _user file_. The _base file_ contains default declarations, such as _accessors_ for the uses ports of the component in each unit. The programmer do not need to modify this file. The _user file_ contains the implementation of the component concern, and may be completed by the programmer of the component;
    * **`bin/<version>` folder**: The folder where the assembly (dll) of each unit is placed. There is a single assembly per unit, including the _base_ and _user_ object code;
    * **`AAA.pub` and `.snk` file**: They are strong key files to sign the assemblies, a requirement of CLI platforms;
    * **`build.xml` file**: This is a make file for [NAnt](http://nant.sourceforge.net/), which is used in the Front-End interface for compilation of the units of the component. The Front-End automatically generates a `build.xml` file before each compilation of the component;
    * **`xxx.yyy.zzz.AAA` folder**: This is the folder of a [MonoDevelop](http://monodevelop.com/) project for the component. It has been created manually by the developers of the COPP versions only for development and test purposes. In order to preserve the dependencies to other projects, which follow the component dependencies, this project must be open in the context of a [MonoDevelop](http://monodevelop.com/) solution placed at the _Eclipse workspace_ folder where the component folders are placed. [Click here to download this solution](http://code.google.com/p/npb-for-hpe/downloads/detail?name=NPB_HPE.sln&can=2&q=#makechanges). However, notice that there are some external references that must be resolved manually. All projects have references to the `DGAC.dll` assembly, which is placed by default in `/usr/lib/mono/DGAC/DGAC.dll` by using the command "`gacutil -i DGAC.dll -package DGAC`". Also, some project make reference to `MPI.dll`, from [MPI.NET](http://osl.iu.edu/research/mpi.net/), and `BMInOut.dll`, from NPB common projects;
  1. Besides their _abstract_ or _concrete_ nature, the parts of the package names of the components say something about their scope and meaning. See below:
    * **`common`**: components that may be reusable accross applications. For example, the `MultiPartition` component, `common.datapartition`, used by SP and BT, may be used by any application that wants to apply the _Multi-Partition Method_ for partitioning and distribution of data accross processes.
    * **`adi`**: componentes related to the ADI (Alternating Direct Implicit) method, which are shared between SP and BT. In fact, SP and BT differ by the implementation of the solver components. Someone could reuse the ADI components to develop an alternative for SP and BT by implementing alternative solver components for the _x_, _y_ and _z_ axis. Such knowledge about the structure of SP and BT is not clearly exposed by the monolithic version;
    * **`sp`**: components used in the context of SP (weak potential of reusing);
    * **`bt`**: components used in the context of BT (weak potential of reusing);
    * **`lu`**: components used in the context of LU (weak potential of reusing);
    * **`ft`**: components used in the context of BT (weak potential of reusing);
    * **`topology`**, **`datapartition`**, **`timer`**, **`solve, *{{{problem_size`**, **`interaction_pattern`**, **`axis`**, etc, are all related to application concerns found in SP, BT, LU and BT. Most of them are parallelism concerns that are not found isolated in the monolithic versions, neither could be isolated in a single components using typical component models and platforms that support parallel processing, such as CCA and Fractal.